// Code generated by protoc-gen-go-mock. DO NOT EDIT.

package examplepb

import (
	context "context"
	fmt "fmt"
	mock "github.com/stretchr/testify/mock"
	grpc "google.golang.org/grpc"
	metadata "google.golang.org/grpc/metadata"
	proto "google.golang.org/protobuf/proto"
	io "io"
	atomic "sync/atomic"
	testing "testing"
)

var _ Service1Client = (*MockService1Client)(nil)

type MockService1Client struct {
	mock.Mock
}

type callService1_Unary struct {
	*mock.Call
}

func (c *callService1_Unary) Return(resp *Message, err error) *mock.Call {
	if resp == nil {
		// otherwise Get(0) interface{} does not pass the != nil check
		// https://golang.org/doc/faq#nil_error
		return c.Call.Return(nil, err)
	}
	return c.Call.Return(resp, err)
}

func (m *MockService1Client) On_Unary(arg *Message) *callService1_Unary {
	return &callService1_Unary{
		Call: m.On("Unary", mock.MatchedBy(func(in *Message) bool {
			return proto.Equal(in, arg)
		})),
	}
}

func (m *MockService1Client) On_Unary_Any() *callService1_Unary {
	return &callService1_Unary{
		Call: m.On("Unary", mock.Anything),
	}
}

func (m *MockService1Client) Assert_Unary_Called(t *testing.T, arg *Message) bool {
	return m.AssertCalled(t, "Unary", arg)
}

func (m *MockService1Client) Assert_Unary_NumberOfCalls(t *testing.T, expectedCalls int) bool {
	return m.AssertNumberOfCalls(t, "Unary", expectedCalls)
}

func (m *MockService1Client) Assert_Unary_NotCalled(t *testing.T, arg *Message) bool {
	return m.AssertNotCalled(t, "Unary", arg)
}

func (m *MockService1Client) Unary(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	var (
		args  = m.Called(in)
		raw   = args.Get(0)
		err   = args.Error(1)
		v, ok = raw.(*Message)
	)
	if raw != nil && !ok {
		panic(fmt.Sprintf("assert: arguments: wanted *Message for Get(0) and not: %T", raw))
	}
	if raw == nil && err == nil {
		panic("assert: arguments: both Get(0) and Error(1) are nil")
	}
	if raw != nil && err != nil {
		panic("assert: arguments: both Get(0) and Error(1) are not nil")
	}
	return v, err
}

var _ Service1_ServerStreamServer = (*MockService1_ServerStreamServer)(nil)

type MockService1_ServerStreamServer struct {
	SentHeader  metadata.MD
	SentTrailer metadata.MD
	sentHeader  bool
	SentObjects []*Message
}

func (m *MockService1_ServerStreamServer) SetHeader(md metadata.MD) error {
	if m.sentHeader {
		return fmt.Errorf("SetHeader cannot be called after SendHeader")
	}
	m.SentHeader = metadata.Join(m.SentHeader, md)
	return nil
}

func (m *MockService1_ServerStreamServer) SendHeader(md metadata.MD) error {
	if m.sentHeader {
		return fmt.Errorf("SendHeader can only be called once")
	}
	m.SentHeader = metadata.Join(m.SentHeader, md)
	m.sentHeader = true
	return nil
}

func (m *MockService1_ServerStreamServer) SetTrailer(md metadata.MD) {
	m.SentTrailer = metadata.Join(m.SentTrailer, md)
}

func (m *MockService1_ServerStreamServer) Context() context.Context {
	return context.TODO()
}

func (m *MockService1_ServerStreamServer) SendMsg(interface{}) error {
	panic("no mocking available for this method")
}

func (m *MockService1_ServerStreamServer) RecvMsg(interface{}) error {
	panic("no mocking available for this method")
}

func (m *MockService1_ServerStreamServer) Send(obj *Message) error {
	m.SentObjects = append(m.SentObjects, obj)
	return nil
}

var _ Service1_ServerStreamClient = (*MockService1_ServerStreamClient)(nil)

type MockService1_ServerStreamClient struct {
	RecvHeader  metadata.MD
	RecvTrailer metadata.MD
	recvOffset  int64
	RecvObjects []*Message
}

func (m *MockService1_ServerStreamClient) Header() (metadata.MD, error) {
	return m.RecvHeader, nil
}

func (m *MockService1_ServerStreamClient) Trailer() metadata.MD {
	return m.RecvTrailer
}

func (m *MockService1_ServerStreamClient) CloseSend() error {
	panic("no mocking available for this method")
}

func (m *MockService1_ServerStreamClient) Context() context.Context {
	return context.TODO()
}

func (m *MockService1_ServerStreamClient) SendMsg(interface{}) error {
	panic("no mocking available for this method")
}

func (m *MockService1_ServerStreamClient) RecvMsg(interface{}) error {
	panic("no mocking available for this method")
}

func (m *MockService1_ServerStreamClient) Recv() (*Message, error) {
	index := atomic.AddInt64(&m.recvOffset, 1) - 1
	if index >= int64(len(m.RecvObjects)) {
		return nil, io.EOF
	}
	return m.RecvObjects[index], nil
}

type callService1_ServerStream struct {
	*mock.Call
}

func (c *callService1_ServerStream) Return(resp Service1_ServerStreamClient, err error) *mock.Call {
	if resp == nil {
		// otherwise Get(0) interface{} does not pass the != nil check
		// https://golang.org/doc/faq#nil_error
		return c.Call.Return(nil, err)
	}
	return c.Call.Return(resp, err)
}

func (c *callService1_ServerStream) Stream(objs ...*Message) *mock.Call {
	return c.Call.Return(&MockService1_ServerStreamClient{RecvObjects: objs}, nil)
}

func (m *MockService1Client) On_ServerStream(arg *Message) *callService1_ServerStream {
	return &callService1_ServerStream{
		Call: m.On("ServerStream", mock.MatchedBy(func(in *Message) bool {
			return proto.Equal(in, arg)
		})),
	}
}

func (m *MockService1Client) On_ServerStream_Any() *callService1_ServerStream {
	return &callService1_ServerStream{
		Call: m.On("ServerStream", mock.Anything),
	}
}

func (m *MockService1Client) Assert_ServerStream_Called(t *testing.T, arg *Message) bool {
	return m.AssertCalled(t, "ServerStream", arg)
}

func (m *MockService1Client) Assert_ServerStream_NumberOfCalls(t *testing.T, expectedCalls int) bool {
	return m.AssertNumberOfCalls(t, "ServerStream", expectedCalls)
}

func (m *MockService1Client) Assert_ServerStream_NotCalled(t *testing.T, arg *Message) bool {
	return m.AssertNotCalled(t, "ServerStream", arg)
}

func (m *MockService1Client) ServerStream(ctx context.Context, in *Message, opts ...grpc.CallOption) (Service1_ServerStreamClient, error) {
	var (
		args  = m.Called(in)
		raw   = args.Get(0)
		err   = args.Error(1)
		v, ok = raw.(Service1_ServerStreamClient)
	)
	if raw != nil && !ok {
		panic(fmt.Sprintf("assert: arguments: wanted Service1_ServerStreamClient for Get(0) and not: %T", raw))
	}
	if raw == nil && err == nil {
		panic("assert: arguments: both Get(0) and Error(1) are nil")
	}
	if raw != nil && err != nil {
		panic("assert: arguments: both Get(0) and Error(1) are not nil")
	}
	return v, err
}

var _ Service2Client = (*MockService2Client)(nil)

type MockService2Client struct {
	mock.Mock
}

type callService2_Unary struct {
	*mock.Call
}

func (c *callService2_Unary) Return(resp *Message, err error) *mock.Call {
	if resp == nil {
		// otherwise Get(0) interface{} does not pass the != nil check
		// https://golang.org/doc/faq#nil_error
		return c.Call.Return(nil, err)
	}
	return c.Call.Return(resp, err)
}

func (m *MockService2Client) On_Unary(arg *Message) *callService2_Unary {
	return &callService2_Unary{
		Call: m.On("Unary", mock.MatchedBy(func(in *Message) bool {
			return proto.Equal(in, arg)
		})),
	}
}

func (m *MockService2Client) On_Unary_Any() *callService2_Unary {
	return &callService2_Unary{
		Call: m.On("Unary", mock.Anything),
	}
}

func (m *MockService2Client) Assert_Unary_Called(t *testing.T, arg *Message) bool {
	return m.AssertCalled(t, "Unary", arg)
}

func (m *MockService2Client) Assert_Unary_NumberOfCalls(t *testing.T, expectedCalls int) bool {
	return m.AssertNumberOfCalls(t, "Unary", expectedCalls)
}

func (m *MockService2Client) Assert_Unary_NotCalled(t *testing.T, arg *Message) bool {
	return m.AssertNotCalled(t, "Unary", arg)
}

func (m *MockService2Client) Unary(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Message, error) {
	var (
		args  = m.Called(in)
		raw   = args.Get(0)
		err   = args.Error(1)
		v, ok = raw.(*Message)
	)
	if raw != nil && !ok {
		panic(fmt.Sprintf("assert: arguments: wanted *Message for Get(0) and not: %T", raw))
	}
	if raw == nil && err == nil {
		panic("assert: arguments: both Get(0) and Error(1) are nil")
	}
	if raw != nil && err != nil {
		panic("assert: arguments: both Get(0) and Error(1) are not nil")
	}
	return v, err
}
