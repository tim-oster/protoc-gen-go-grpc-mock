package main

import (
	"google.golang.org/protobuf/compiler/protogen"
)

// inspiration from: https://github.com/golang/protobuf/blob/master/internal/gengogrpc/grpc.go

const (
	fmtPackage      = protogen.GoImportPath("fmt")
	contextPackage  = protogen.GoImportPath("context")
	atomicPackage   = protogen.GoImportPath("sync/atomic")
	ioPackage       = protogen.GoImportPath("io")
	testingPackage  = protogen.GoImportPath("testing")
	protoPackage    = protogen.GoImportPath("google.golang.org/protobuf/proto")
	grpcPackage     = protogen.GoImportPath("google.golang.org/grpc")
	metadataPackage = protogen.GoImportPath("google.golang.org/grpc/metadata")
	mockPackage     = protogen.GoImportPath("github.com/stretchr/testify/mock")
)

func main() {
	var opts protogen.Options
	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_mock.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-mock. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, service := range file.Services {
		generateService(g, service)
	}

	return g
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) {
	clientName := service.GoName + "Client"

	g.P("var _ ", clientName, " = (*Mock", clientName, ")(nil)")
	g.P()

	g.P("type Mock", clientName, " struct {")
	g.P(g.QualifiedGoIdent(mockPackage.Ident("Mock")))
	g.P("}")
	g.P()

	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() {
			generateServerStreamingMock(g, method)
			generateClientStreamingMock(g, method)
		}
		generateClientMethodMock(g, method, clientName)
	}
}

func clientSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	s := method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
	if !method.Desc.IsStreamingClient() {
		s += ", in *" + g.QualifiedGoIdent(method.Input.GoIdent)
	}
	s += ", opts ..." + g.QualifiedGoIdent(grpcPackage.Ident("CallOption")) + ") ("
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		s += "*" + g.QualifiedGoIdent(method.Output.GoIdent)
	} else {
		s += method.Parent.GoName + "_" + method.GoName + "Client"
	}
	s += ", error)"
	return s
}

func generateServerStreamingMock(g *protogen.GeneratedFile, method *protogen.Method) {
	var (
		respType    = g.QualifiedGoIdent(method.Output.GoIdent)
		identErrorf = g.QualifiedGoIdent(fmtPackage.Ident("Errorf"))
		md          = g.QualifiedGoIdent(metadataPackage.Ident("MD"))
		ctx         = g.QualifiedGoIdent(contextPackage.Ident("Context"))
		ctxTodo     = g.QualifiedGoIdent(contextPackage.Ident("TODO"))
	)

	interfaceName := method.Parent.GoName + "_" + method.GoName + "Server"
	name := "Mock" + interfaceName

	g.P("var _ ", interfaceName, " = (*", name, ")(nil)")
	g.P()

	g.P("type ", name, " struct {")
	g.P("SentHeader ", md)
	g.P("SentTrailer ", md)
	g.P("sentHeader bool")
	g.P("SentObjects []*", respType)
	g.P("}")
	g.P()

	// satisfy the grpc.ServerStream interface
	g.P("func (m *", name, ") SetHeader(md ", md, ") error {")
	g.P("if m.sentHeader {")
	g.P(`return `, identErrorf, `("SetHeader cannot be called after SendHeader")`)
	g.P("}")
	g.P("m.SentHeader = metadata.Join(m.SentHeader, md)")
	g.P("return nil")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") SendHeader(md ", md, ") error {")
	g.P("if m.sentHeader {")
	g.P(`return `, identErrorf, `("SendHeader can only be called once")`)
	g.P("}")
	g.P("m.SentHeader = metadata.Join(m.SentHeader, md)")
	g.P("m.sentHeader = true")
	g.P("return nil")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") SetTrailer(md ", md, ") {")
	g.P("m.SentTrailer = metadata.Join(m.SentTrailer, md)")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") Context() ", ctx, " {")
	g.P("return ", ctxTodo, "()")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") SendMsg(interface{}) error {")
	g.P("panic(\"no mocking available for this method\")")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") RecvMsg(interface{}) error {")
	g.P("panic(\"no mocking available for this method\")")
	g.P("}")
	g.P()

	// satisfy the server stream interface for this method
	g.P("func (m *", name, ") Send(obj *", respType, ") error {")
	g.P("m.SentObjects = append(m.SentObjects, obj)")
	g.P("return nil")
	g.P("}")
	g.P()
}

func generateClientStreamingMock(g *protogen.GeneratedFile, method *protogen.Method) {
	var (
		respType       = g.QualifiedGoIdent(method.Output.GoIdent)
		md             = g.QualifiedGoIdent(metadataPackage.Ident("MD"))
		ctx            = g.QualifiedGoIdent(contextPackage.Ident("Context"))
		ctxTodo        = g.QualifiedGoIdent(contextPackage.Ident("TODO"))
		atomicAddInt64 = g.QualifiedGoIdent(atomicPackage.Ident("AddInt64"))
		ioEof          = g.QualifiedGoIdent(ioPackage.Ident("EOF"))
	)

	interfaceName := method.Parent.GoName + "_" + method.GoName + "Client"
	name := "Mock" + interfaceName

	g.P("var _ ", interfaceName, " = (*", name, ")(nil)")
	g.P()

	g.P("type ", name, " struct {")
	g.P("RecvHeader ", md)
	g.P("RecvTrailer ", md)
	g.P("recvOffset int64")
	g.P("RecvObjects []*", respType)
	g.P("}")
	g.P()

	// satisfy the grpc.ClientStream interface
	g.P("func (m *", name, ") Header() (", md, ", error) {")
	g.P("return m.RecvHeader, nil")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") Trailer() ", md, " {")
	g.P("return m.RecvTrailer")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") CloseSend() error {")
	g.P("panic(\"no mocking available for this method\")")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") Context() ", ctx, " {")
	g.P("return ", ctxTodo, "()")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") SendMsg(interface{}) error {")
	g.P("panic(\"no mocking available for this method\")")
	g.P("}")
	g.P()

	g.P("func (m *", name, ") RecvMsg(interface{}) error {")
	g.P("panic(\"no mocking available for this method\")")
	g.P("}")
	g.P()

	// satisfy the client stream interface for this method
	g.P("func (m *", name, ") Recv() (*", respType, ", error) {")
	g.P("index := ", atomicAddInt64, "(&m.recvOffset, 1) - 1")
	g.P("if index >= int64(len(m.RecvObjects)) {")
	g.P("return nil, ", ioEof)
	g.P("}")
	g.P("return m.RecvObjects[index], nil")
	g.P("}")
	g.P()
}

func generateClientMethodMock(g *protogen.GeneratedFile, method *protogen.Method, clientName string) {
	var (
		identCall      = g.QualifiedGoIdent(mockPackage.Ident("Call"))
		identMatchedBy = g.QualifiedGoIdent(mockPackage.Ident("MatchedBy"))
		identSprintf   = g.QualifiedGoIdent(fmtPackage.Ident("Sprintf"))
		identT         = g.QualifiedGoIdent(testingPackage.Ident("T"))

		reqType        = g.QualifiedGoIdent(method.Input.GoIdent)
		actualRespType = "*" + g.QualifiedGoIdent(method.Output.GoIdent)
		respType       = actualRespType
	)

	if method.Desc.IsStreamingClient() {
		g.P("func (*Mock", clientName, ") ", clientSignature(g, method), "{")
		g.P("panic(\"client side streams are currently not mock-able\")")
		g.P("}")
		g.P()

		return
	}

	if method.Desc.IsStreamingServer() {
		respType = method.Parent.GoName + "_" + method.GoName + "Client"
	}

	// generate extension of mock.Call to provide type safe Return method
	callMock := "call" + method.Parent.GoName + "_" + method.GoName
	g.P("type ", callMock, " struct {")
	g.P("*", identCall)
	g.P("}")
	g.P()

	g.P("func (c *", callMock, ") Return(resp ", respType, ", err error) *", identCall, " {")
	g.P("if resp == nil {")
	g.P("// otherwise Get(0) interface{} does not pass the != nil check")
	g.P("// https://golang.org/doc/faq#nil_error")
	g.P("return c.Call.Return(nil, err)")
	g.P("}")
	g.P("return c.Call.Return(resp, err)")
	g.P("}")
	g.P()

	if method.Desc.IsStreamingServer() {
		name := "Mock" + method.Parent.GoName + "_" + method.GoName + "Client"
		g.P("func (c *", callMock, ") Stream(objs ...", actualRespType, ") *", identCall, " {")
		g.P("return c.Call.Return(&", name, "{RecvObjects: objs}, nil)")
		g.P("}")
		g.P()
	}

	// generate On_xxx method that takes the actual request object for matching the mocked request
	g.P("func (m *Mock", clientName, ") On_", method.GoName, " (arg *", reqType, ") *", callMock, " {")
	g.P("return &", callMock, "{")
	g.P("Call: m.On(\"", method.GoName, "\", ", identMatchedBy, "(func(in *", reqType, ") bool {")
	g.P("return ", g.QualifiedGoIdent(protoPackage.Ident("Equal")), "(in, arg)")
	g.P("})),")
	g.P("}")
	g.P("}")
	g.P()

	// generate On_xxx_Any to define a response for any given request
	g.P("func (m *Mock", clientName, ") On_", method.GoName, "_Any () *", callMock, " {")
	g.P("return &", callMock, "{")
	g.P("Call: m.On(\"", method.GoName, "\", ", g.QualifiedGoIdent(mockPackage.Ident("Anything")), "),")
	g.P("}")
	g.P("}")
	g.P()

	// generate Assert_xxx_Called
	g.P("func (m *Mock", clientName, ") Assert_", method.GoName, "_Called (t *", identT, ", arg *", reqType, ") bool {")
	g.P("return m.AssertCalled(t, \"", method.GoName, "\", arg)")
	g.P("}")
	g.P()

	// generate Assert_xxx_NumberOfCalls
	g.P("func (m *Mock", clientName, ") Assert_", method.GoName, "_NumberOfCalls (t *", identT, ", expectedCalls int) bool {")
	g.P("return m.AssertNumberOfCalls(t, \"", method.GoName, "\", expectedCalls)")
	g.P("}")
	g.P()

	// generate Assert_xxx_NotCalled
	g.P("func (m *Mock", clientName, ") Assert_", method.GoName, "_NotCalled (t *", identT, ", arg *", reqType, ") bool {")
	g.P("return m.AssertNotCalled(t, \"", method.GoName, "\", arg)")
	g.P("}")
	g.P()

	// generate the actual method that satisfies the interface and implements the necessary mocking logic
	g.P("func (m *Mock", clientName, ") ", clientSignature(g, method), "{")
	g.P("var (")
	g.P("args = m.Called(in)")
	g.P("raw = args.Get(0)")
	g.P("err = args.Error(1)")
	g.P("v, ok = raw.(", respType, ")")
	g.P(")")
	g.P("if raw != nil && !ok {")
	g.P("panic(", identSprintf, "(\"assert: arguments: wanted ", respType, " for Get(0) and not: %T\", raw))")
	g.P("}")
	g.P("if raw == nil && err == nil {")
	g.P("panic(\"assert: arguments: both Get(0) and Error(1) are nil\")")
	g.P("}")
	g.P("if raw != nil && err != nil {")
	g.P("panic(\"assert: arguments: both Get(0) and Error(1) are not nil\")")
	g.P("}")
	g.P("return v, err")
	g.P("}")
	g.P()
}
